use crate::networking::Command;

use std::{
    fmt::{Debug, Display},
    str::FromStr,
};

#[rustfmt::skip]
#[derive(Debug, PartialEq)]
pub enum ClientCommand {
    Handshake(String),                           // HI#<hdid:String>#%
    ClientVersion(u32, String, String),          /* ID#<pv:u32>#<software:String>#
                                                  * <version:String>#% */
    KeepAlive(i32),                                   // CH
    AskListLengths,                              // askchaa
    AskListCharacters,                           // askchar
    CharacterList(u32),                          // AN#<page:u32>#%
    EvidenceList(u32),                           // AE#<page:u32>#%
    MusicList(u32),                              // AM#<page:u32>#%
    AO2CharacterList,                            // AC#%
    AO2MusicList,                                // AM#%
    AO2Ready,                                    // RD#%
    SelectCharacter(u32, u32, String),           /* CC<client_id:u32>#
                                                  * <char_id:u32#<hdid:
                                                  * String>#% */
    ICMessage,                                   // MS
    OOCMessage(String, String),                  /* CT#<name:String>#
                                                  * <message:String>#% */
    PlaySong(u32, u32),                          // MC#<song_name:u32>#<???:u32>#%
    WTCEButtons(String),                         // RT#<type:String>#%
    SetCasePreferences(String, CasePreferences), /* SETCASE#<cases:String>#<will_cm:boolean>#<will_def:boolean>#<will_pro:boolean>#<will_judge:boolean>#<will_jury:boolean>#<will_steno:boolean>#% */
    CaseAnnounce(String, CasePreferences),       // CASEA
    Penalties(u32, u32),                         /* HP#<type:u32>#
                                                  * <new_value:u32>#% */
    AddEvidence(EvidenceArgs),                   /* PE#<name:String>#<description:String>#
                                                  * <image:String>#% */
    DeleteEvidence(u32),                         // DE#<id:u32>#%
    EditEvidence(u32, EvidenceArgs),             /* EE#<id:u32>#<name:String>#
                                                  * <description:String>#<image:
                                                  * String>#% */
    CallModButton(Option<String>),               // ZZ?#<reason:String>?#%
}

impl Command for ClientCommand {
    fn from_protocol<'a>(
        name: String,
        mut args: impl Iterator<Item = String>,
    ) -> Result<Self, anyhow::Error> {
        let on_err = || {
            anyhow::anyhow!(
                "Amount of arguments for command {} does not match!",
                &name
            )
        };

        let res = match name.as_str() {
            "HI" => Ok(Self::Handshake(next_arg(&mut args, on_err)?)),
            "CH" => Ok(Self::KeepAlive(next_arg(&mut args, on_err)?)),
            _ => Err(on_err()),
        }?;
        assert_iterator_is_empty(args).map(|_| res)
    }

    fn ident(&self) -> &'static str {
        use ClientCommand::*;

        match self {
            Handshake(_) => "HI",
            KeepAlive(_) => "CH",
            _ => todo!("Will be generated by macro!"),
        }
    }

    fn extract_args(&self) -> Vec<&str> {
        use ClientCommand::*;

        match self {
            Handshake(s) => vec![s],
            KeepAlive(_) => vec![],
            _ => todo!("Will be generated by macro!"),
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct EvidenceArgs {
    pub name: String,
    pub description: String,
    pub image: String,
}

#[derive(Debug, PartialEq)]
pub struct CasePreferences {
    pub cm: bool,
    pub def: bool,
    pub pro: bool,
    pub judge: bool,
    pub jury: bool,
    pub steno: bool,
}

pub fn next_arg<E, T, F>(
    mut args: impl Iterator<Item = String>,
    on_err: F,
) -> Result<T, anyhow::Error>
where
    E: Display,
    T: FromStr<Err = E>,
    F: Fn() -> anyhow::Error,
{
    args.next()
        .ok_or_else(on_err)
        .map(|s| s.parse::<T>().map_err(|e| anyhow::anyhow!("{}", e)))
        .and_then(std::convert::identity)
}

pub fn assert_iterator_is_empty<T>(
    mut iter: impl Iterator<Item = T>,
) -> Result<(), anyhow::Error> {
    match iter.next().is_none() {
        true => Ok(()),
        false => Err(anyhow::anyhow!("Too many arguments!")),
    }
}

#[rustfmt::skip]
#[derive(Debug)]
pub enum ServerCommand {
    Handshake(String),
    KeepAlive,
}

impl Command for ServerCommand {
    fn from_protocol(
        _name: String,
        _args: impl Iterator<Item = String>,
    ) -> Result<Self, anyhow::Error>
    where
        Self: Sized,
    {
        Err(anyhow::anyhow!("Cannot be made from protocol! (Server response)"))
    }

    fn ident(&self) -> &str {
        use ServerCommand::*;

        match self {
            Handshake(_) => "HI",
            KeepAlive => "CHECK"
        }
    }

    fn extract_args(&self) -> Vec<&str> {
        use ServerCommand::*;

        match self {
            Handshake(str) => vec![str],
            KeepAlive => vec![],
        }
    }
}
